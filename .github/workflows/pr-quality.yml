name: PR Quality Check

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to check (optional)'
        required: false
        type: number

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  quality-check:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Quality Checks
        id: checks
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              errors: [],
              warnings: [],
              info: []
            };
            
            let pr = null;
            
            // Handle manual trigger with PR number
            if (context.eventName === 'workflow_dispatch' && context.payload.inputs?.pr_number) {
              const prNumber = parseInt(context.payload.inputs.pr_number);
              try {
                const response = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                pr = response.data;
              } catch (e) {
                console.log(`Could not fetch PR #${prNumber}: ${e.message}`);
                core.setFailed(`PR #${prNumber} not found`);
                return;
              }
            } else if (context.payload.pull_request) {
              pr = context.payload.pull_request;
            } else {
              console.log('No PR context available - running in test mode');
              results.info.push('Running in test mode without PR context');
              core.setOutput('results', JSON.stringify(results));
              return results;
            }
            
            // 1. Title validation
            const titlePattern = /^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .+/;
            if (!titlePattern.test(pr.title)) {
              results.warnings.push('PR title should follow conventional commits');
            }
            
            // 2. Branch name validation
            const branchPattern = /^(feature|fix|docs|hotfix|priority)\/\d+-[\w-]+$/;
            if (!branchPattern.test(pr.head.ref)) {
              results.warnings.push('Branch name should follow type/issue-number-description');
            }
            
            // 3. Size analysis
            const total = pr.additions + pr.deletions;
            let sizeLabel = 'size/XS';
            if (total > 500) {
              sizeLabel = 'size/XL';
              results.warnings.push('Large PR - consider splitting');
            } else if (total > 250) {
              sizeLabel = 'size/L';
            } else if (total > 100) {
              sizeLabel = 'size/M';
            } else if (total > 10) {
              sizeLabel = 'size/S';
            }
            
            // 4. Issue linkage
            const body = pr.body || '';
            const hasIssueLink = /(fixes|closes|resolves)\s+#\d+/i.test(body);
            if (!hasIssueLink) {
              results.warnings.push('No linked issue found');
            }
            
            // 5. Description completeness
            const hasResolution = /resolution:|##\s*resolution/i.test(body);
            if (hasIssueLink && !hasResolution) {
              results.warnings.push('Missing Resolution section');
            }
            
            // 6. Assignment check
            if (!pr.assignee) {
              results.errors.push('PR must be assigned');
            }
            
            // Add size label
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(prNumber),
                labels: [sizeLabel]
              });
            } catch (e) {
              console.log('Could not add label:', e.message);
            }
            
            core.setOutput('results', JSON.stringify(results));
            core.setOutput('pr_number', pr.number);
            return results;

      - name: Post Results Comment
        if: always() && steps.checks.outputs.pr_number
        uses: actions/github-script@v7
        with:
          script: |
            const resultsJson = '${{ steps.checks.outputs.results }}';
            const prNumber = '${{ steps.checks.outputs.pr_number }}';
            
            if (!resultsJson || resultsJson === '') {
              console.log('No results to post');
              return;
            }
            
            const results = JSON.parse(resultsJson);
            
            let comment = '## 🔍 PR Quality Check\n\n';
            
            if (results.errors && results.errors.length > 0) {
              comment += '### ❌ Errors (Must Fix)\n';
              results.errors.forEach(e => comment += `- ${e}\n`);
              comment += '\n';
            }
            
            if (results.warnings && results.warnings.length > 0) {
              comment += '### ⚠️ Warnings (Recommended)\n';
              results.warnings.forEach(w => comment += `- ${w}\n`);
              comment += '\n';
            }
            
            if (results.info && results.info.length > 0) {
              comment += '### ℹ️ Information\n';
              results.info.forEach(i => comment += `- ${i}\n`);
              comment += '\n';
            }
            
            comment += '### 📋 PR Checklist\n';
            comment += '- [ ] Tests pass locally\n';
            comment += '- [ ] Documentation updated\n';
            comment += '- [ ] No merge conflicts\n';
            comment += '- [ ] Issue linked with Fixes #XXX\n';
            comment += '\n---\n';
            comment += '*[Contributing Guide](CONTRIBUTING.md) | [Development Standards](rules/CRITICAL_CORE.mdc)*';
            
            // Find and update existing comment or create new
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(prNumber)
            });
            
            const botComment = comments.find(c => 
              c.user.type === 'Bot' && c.body.includes('PR Quality Check')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(prNumber),
                body: comment
              });
            }
            
            // Fail if errors
            if (results.errors && results.errors.length > 0) {
              core.setFailed('PR has quality issues that must be fixed');
            }